<!DOCTYPE HTML>
<html lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<title>function argument callee</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
	<meta name="description" content="请输入您的描述信息">
	<meta name="keywords" content="关键字,关键字,关键字">
	<meta name="author" content="Simon Sun">
	<style></style>
	<script>
		// function box(num) {
		// 	if(num<=1){
		// 		return 1;
		// 	}else{
		// 		return num*box(num-1);
		// 		// 递归：程序调用自身的编程技巧称之为递归（recursion）
		// 	}
		// }
		// alert(box(4));
		// 
		// 在函数内部，有两个特殊的对象：arguments 和this。arguments 是一个类数组对象，包
		// 含着传入函数中的所有参数，主要用途是保存函数参数。但这个对象还有一个名叫callee 的属性，该属性是一个指针，指向拥有这个arguments 			对象的函数
		// function box(num) {
		// 	if(num<=1){
		// 		return 1;
		// 	}else{
		// 		return num*arguments.callee(num-1);
		// 		// 递归：程序调用自身的编程技巧称之为递归（recursion）
		// 	}
		// }
		// alert(box(4));
		// 
		// function box(name,age) {
		// 	return name+age;
		// }
		// alert(box.length);
		// PS：对于prototype 属性，它是保存所有实例方法的真正所在，也就是原型。这个属性，
		// 我们将在面向对象一章详细介绍。而prototype 下有两个方法：apply()和call()，每个函数都
		// 包含这两个非继承而来的方法。这两个方法的用途都在特定的作用域中调用函数，实际上等
		// 于设置函数体内this 对象的值。
		// 
		function box(num1,num2) {
			return num1+num2;
		}
		// function sum(num1,num2) {
		// 	return box.apply(this,[num1,num2]);
		// 	//this window作用域，【】传递参数
		// }
		// alert(sum(10,10));
		// 对象冒充 sum 本身没有相加功能。冒充了 box
		//apply 参数多 
		// function sum2(num1,num2) {
		// 	return box.apply(this,arguments);
		// }
		// alert(sum2(10,10));
		// 
		//call 方法可以一个一个传递参数，call 【】数组传递
		function sum(num1,num2) {
			return box.call(this,num1,num2);
		}
		alert(sum(10,10));

		//为什么要冒充：改变作用域；
		//
		// var color="红色";
		// var box={
		// 	color:"蓝色"
		// }
		// //用call 实现对象冒充 冒充window
		// function sayColor() {
		// 	alert(this.color);
		// }
		// // sayColor();
		// // sayColor.call(window);
		// // sayColor.call(this);
		// sayColor();//box,作用域在box对象里面；blue
		// sayColor.call(box);//box,作用域在box对象里面；blue
		// // 使用call()或者apply()来扩充作用域的最大好处，就是对象不需要与方法发生任何耦合
		// 关系(耦合，就是互相关联的意思，扩展和维护会发生连锁反应)。也就是说，box 对象和
		// // sayColor()方法之间不会有多余的关联操作，比如box.sayColor = sayColor;
	</script>
</head>
<body>
	
</body>
</html>